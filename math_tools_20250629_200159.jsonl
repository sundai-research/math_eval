{"type": "function", "function": {"name": "TrigExpressionSimplifier", "description": "Simplifies trigonometric expressions using symbolic manipulation and known identities", "parameters": {"type": "object", "properties": {"expression": {"type": "string", "description": "A string representation of the trigonometric expression to simplify"}}, "required": ["expression"]}}, "python_implementation": "def TrigExpressionSimplifier(expression: str) -> Dict:\n    \"\"\"Simplifies trigonometric expressions using SymPy\"\"\"\n    import sympy as sp\n    try:\n        # Parse the expression\n        expr = sp.sympify(expression)\n        # Apply simplification\n        simplified = sp.simplify(expr)\n        return {\n            \"result\": str(simplified),\n            \"steps\": [\"Parsed expression\", \"Applied SymPy simplification\"]\n        }\n    except Exception as e:\n        return {\"error\": str(e)}", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "check_skew_perpendicular_lines", "description": "Checks if two lines in 3D space are both skew and perpendicular by analyzing their direction vectors and spatial relationships.", "parameters": {"type": "object", "properties": {"line1": {"type": "array", "description": "A tuple of two 3D points (each as a tuple of coordinates) representing the first line."}, "line2": {"type": "array", "description": "A tuple of two 3D points (each as a tuple of coordinates) representing the second line."}}, "required": ["line1", "line2"]}}, "python_implementation": "def check_skew_perpendicular_lines(line1, line2):\n    import numpy as np\n    \n    # Extract points\n    p1, p2 = np.array(line1), np.array(line2)\n    \n    # Compute direction vectors\n    v1 = p2 - p1\n    v2 = np.array(line2[1]) - np.array(line2[0])\n    \n    # Check perpendicularity (dot product)\n    if np.dot(v1, v2) != 0:\n        return False\n    \n    # Check parallelism (cross product magnitude)\n    cross = np.cross(v1, v2)\n    if np.allclose(cross, 0):\n        return False\n    \n    # Check skewness using scalar triple product\n    p_diff = np.array(line2[0]) - p1\n    scalar_triple = np.dot(p_diff, cross)\n    return np.abs(scalar_triple) > 1e-10", "required_imports": ["numpy"]}
{"type": "function", "function": {"name": "NonIntersectingPathsCalculator", "description": "Calculates the number of non-intersecting path pairs between two pairs of points using the Lindström–Gessel–Viennot lemma (LGV lemma).", "parameters": {"type": "object", "properties": {"start1": {"type": "tuple", "description": "Coordinates (x, y) of the first starting point"}, "end1": {"type": "tuple", "description": "Coordinates (x, y) of the first ending point"}, "start2": {"type": "tuple", "description": "Coordinates (x, y) of the second starting point"}, "end2": {"type": "tuple", "description": "Coordinates (x, y) of the second ending point"}}, "required": ["start1", "end1", "start2", "end2"]}}, "python_implementation": "def NonIntersectingPathsCalculator(start1: tuple, end1: tuple, start2: tuple, end2: tuple) -> dict:\n    from math import comb\n    def path_count(s, e):\n        dx = e[0] - s[0]\n        dy = e[1] - s[1]\n        if dx < 0 or dy < 0:\n            return 0\n        return comb(dx + dy, dx)\n    \n    a = path_count(start1, end1)\n    b = path_count(start1, end2)\n    c = path_count(start2, end1)\n    d = path_count(start2, end2)\n    \n    determinant = a*d - b*c\n    return {\n        \"result\": determinant,\n        \"steps\": [\n            f\"Paths from {start1} to {end1}: {a}\",\n            f\"Paths from {start1} to {end2}: {b}\",\n            f\"Paths from {start2} to {end1}: {c}\",\n            f\"Paths from {start2} to {end2}: {d}\",\n            f\"Non-intersecting paths: {determinant}\"\n        ]\n    }", "required_imports": ["math.comb"]}
{"type": "function", "function": {"name": "circle_distance_minimizer", "description": "Finds the minimum sum of distances from a point on a circle to two fixed points using numerical optimization", "parameters": {"type": "object", "properties": {"circle_center": {"type": "array", "description": "Coordinates [x, y] of the circle's center"}, "radius": {"type": "float", "description": "Radius of the circle"}, "point1": {"type": "array", "description": "Coordinates [x, y] of the first fixed point"}, "point2": {"type": "array", "description": "Coordinates [x, y] of the second fixed point"}}, "required": ["circle_center", "radius", "point1", "point2"]}}, "python_implementation": "def circle_distance_minimizer(circle_center, radius, point1, point2):\n    \"\"\"Computes minimum sum of distances from circle to two points using numerical optimization\"\"\"\n    import numpy as np\n    from scipy.optimize import minimize_scalar\n    \n    def distance_sum(theta):\n        x = circle_center[0] + radius * np.cos(theta)\n        y = circle_center[1] + radius * np.sin(theta)\n        d1 = np.sqrt((x - point1[0])**2 + (y - point1[1])**2)\n        d2 = np.sqrt((x - point2[0])**2 + (y - point2[1])**2)\n        return d1 + d2\n    \n    result = minimize_scalar(distance_sum, bounds=(0, 2*np.pi), method='bounded')\n    return {\n        'minimum_value': result.fun,\n        'theta': result.x,\n        'steps': ['Parametrized circle', 'Computed distance sum', 'Optimized using scalar minimization']\n    }", "required_imports": ["numpy", "scipy.optimize"]}
