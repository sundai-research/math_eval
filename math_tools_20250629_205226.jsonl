{"type": "function", "function": {"name": "reflect_point_over_line", "description": "Reflects a point (x0, y0) over a line defined by Ax + By + C = 0 using the standard reflection formula.", "parameters": {"type": "object", "properties": {"A": {"type": "float", "description": "Coefficient of x in the line equation"}, "B": {"type": "float", "description": "Coefficient of y in the line equation"}, "C": {"type": "float", "description": "Constant term in the line equation"}, "x0": {"type": "float", "description": "x-coordinate of the point to reflect"}, "y0": {"type": "float", "description": "y-coordinate of the point to reflect"}}, "required": ["A", "B", "C", "x0", "y0"]}}, "python_implementation": "async def reflect_point_over_line(A: float, B: float, C: float, x0: float, y0: float) -> dict:\n    denominator = A**2 + B**2\n    if denominator == 0:\n        return {'error': 'Invalid line equation (A and B cannot both be zero)'}\n    numerator = A*x0 + B*y0 + C\n    x_reflect = x0 - 2*A*numerator / denominator\n    y_reflect = y0 - 2*B*numerator / denominator\n    return {'x': x_reflect, 'y': y_reflect, 'steps': ['Computed reflection using standard formula']}", "required_imports": ["math"]}
{"type": "function", "function": {"name": "conic_line_intersection", "description": "Find intersection points between a conic section and a line using symbolic computation.", "parameters": {"type": "object", "properties": {"conic_equation": {"type": "string", "description": "The equation of the conic section (e.g., 'x**2/a**2 - y**2/b**2 - 1')"}, "line_equation": {"type": "string", "description": "The equation of the line (e.g., 'y - k*x')"}}, "required": ["conic_equation", "line_equation"]}}, "python_implementation": "async def conic_line_intersection(conic_equation: str, line_equation: str) -> dict:\n    from sympy import symbols, Eq, solve\n    x, y = symbols('x y')\n    conic = Eq(eval(conic_equation), 0)\n    line = Eq(eval(line_equation), 0)\n    solutions = solve((conic, line), (x, y))\n    return {\n        'intersection_points': solutions,\n        'steps': ['Substituted line equation into conic', 'Solved system of equations']\n    }", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "3D_Line_Perpendicularity_Skew_Check", "description": "Analyzes two 3D lines to determine if they are perpendicular and skew. Uses vector math and geometric checks to validate properties.", "parameters": {"type": "object", "properties": {"line1": {"type": "array", "description": "First line defined by two 3D points [p1, p2]"}, "line2": {"type": "array", "description": "Second line defined by two 3D points [p3, p4]"}}, "required": ["line1", "line2"]}}, "python_implementation": "async def 3D_Line_Perpendicularity_Skew_Check(line1: list, line2: list) -> dict:\n    from sympy import Line3D\n    import numpy as np\n    \n    # Extract points\n    p1, p2 = np.array(line1[0]), np.array(line1[1])\n    p3, p4 = np.array(line2[0]), np.array(line2[1])\n    \n    # Create Line3D objects\n    l1 = Line3D(p1, p2)\n    l2 = Line3D(p3, p4)\n    \n    # Check perpendicularity\n    dir1 = np.array(l1.direction_ratio)\n    dir2 = np.array(l2.direction_ratio)\n    dot_product = np.dot(dir1, dir2)\n    is_perpendicular = np.isclose(dot_product, 0)\n    \n    # Check skewness\n    is_parallel = l1.is_parallel(l2)\n    intersects = len(l1.intersection(l2)) > 0\n    is_skew = not is_parallel and not intersects\n    \n    return {\n        \"is_perpendicular\": is_perpendicular,\n        \"is_skew\": is_skew,\n        \"steps\": [\"Calculated direction vectors\", \"Checked dot product for perpendicularity\", \"Verified parallelism and intersection status\"]\n    }", "required_imports": ["sympy", "numpy"]}
{"type": "function", "function": {"name": "NonIntersectingPathsDeterminant", "description": "Calculates the number of non-intersecting path pairs between two pairs of points using the Lindström-Gessel-Viennot lemma. Computes the determinant of a 2x2 matrix of path counts.", "parameters": {"type": "object", "properties": {"start1": {"type": "tuple", "description": "Coordinates of the first starting point (x1, y1)"}, "end1": {"type": "tuple", "description": "Coordinates of the first ending point (x2, y2)"}, "start2": {"type": "tuple", "description": "Coordinates of the second starting point (x3, y3)"}, "end2": {"type": "tuple", "description": "Coordinates of the second ending point (x4, y4)"}}, "required": ["start1", "end1", "start2", "end2"]}}, "python_implementation": "async def NonIntersectingPathsDeterminant(start1: tuple, end1: tuple, start2: tuple, end2: tuple) -> dict:\n    from math import comb\n    \n    def count_paths(start, end):\n        dx = end[0] - start[0]\n        dy = end[1] - start[1]\n        if dx < 0 or dy < 0:\n            return 0\n        return comb(dx + dy, dx)\n    \n    m11 = count_paths(start1, end1)\n    m12 = count_paths(start1, end2)\n    m21 = count_paths(start2, end1)\n    m22 = count_paths(start2, end2)\n    \n    determinant = m11 * m22 - m12 * m21\n    \n    return {\n        \"result\": determinant,\n        \"steps\": [\n            f\"Paths from {start1} to {end1}: {m11}\",\n            f\"Paths from {start1} to {end2}: {m12}\",\n            f\"Paths from {start2} to {end1}: {m21}\",\n            f\"Paths from {start2} to {end2}: {m22}\",\n            f\"Determinant (non-intersecting paths): {determinant}\"\n        ]\n    }", "required_imports": ["math.comb"]}
{"type": "function", "function": {"name": "TrigExpressionSimplifier", "description": "Simplifies trigonometric expressions using symbolic manipulation and identity application", "parameters": {"type": "object", "properties": {"expression": {"type": "string", "description": "The trigonometric expression to simplify"}}, "required": ["expression"]}}, "python_implementation": "async def TrigExpressionSimplifier(expression: str) -> Dict:\n    \"\"\"Simplifies trigonometric expressions using symbolic manipulation\"\"\"\n    import sympy as sp\n    try:\n        # Parse expression\n        expr = sp.sympify(expression)\n        # Apply simplification with trigonometric identities\n        simplified = sp.simplify(expr)\n        # Check for common trigonometric identities\n        for identity in [sp.trigidentities()]:\n            simplified = simplified.subs(identity[0], identity[1])\n        return {\n            \"result\": str(simplified),\n            \"steps\": [\"Parsed expression\", \"Applied trigonometric identities\", \"Simplified result\"]\n        }\n    except Exception as e:\n        return {\"error\": str(e)}", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "find_conic_line_intersections", "description": "Finds the intersection points between a line and a conic section given their equations.", "parameters": {"type": "object", "properties": {"line_equation": {"type": "string", "description": "The equation of the line in standard form (e.g., 'y = m*x + c' or 'A*x + B*y + C = 0')"}, "conic_equation": {"type": "string", "description": "The equation of the conic section in standard form (e.g., 'x^2/a^2 + y^2/b^2 = 1')"}}, "required": ["line_equation", "conic_equation"]}}, "python_implementation": "async def find_conic_line_intersections(line_equation: str, conic_equation: str) -> dict:\n    \"\"\"Finds intersection points between a line and conic using sympy.\"\"\"\n    from sympy import symbols, Eq, solve\n    x, y = symbols('x y')\n    \n    # Parse line equation\n    try:\n        line_expr = Eq(eval(line_equation.replace('=', '-')), 0)\n    except:\n        line_expr = Eq(eval(line_equation), 0)\n    \n    # Parse conic equation\n    try:\n        conic_expr = Eq(eval(conic_equation.replace('=', '-')), 0)\n    except:\n        conic_expr = Eq(eval(conic_equation), 0)\n    \n    # Solve system\n    solutions = solve((line_expr, conic_expr), (x, y))\n    \n    return {\n        'intersection_points': [(float(sol[x]), float(sol[y])) for sol in solutions],\n        'steps': ['Parsed equations', 'Solved system of equations']\n    }", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "exhaustion_probability_calculator", "description": "Calculates the probability that a specific color is the first to be completely taken out from a collection of multiple colors using combinatorial probability principles.", "parameters": {"type": "object", "properties": {"counts": {"type": "array", "description": "Array of counts for each color (e.g., [red, yellow, blue])"}}, "required": ["counts"]}}, "python_implementation": "async def exhaustion_probability_calculator(counts: list) -> dict:\n    from math import comb\n    red, yellow, blue = counts\n    total = red + yellow + blue\n    # Correct formula: (yellow * blue) / ((red + yellow) * (red + blue)) * (total / (total - 1))\n    # This is a placeholder; actual implementation requires deeper combinatorial analysis\n    numerator = yellow * blue\n    denominator = (red + yellow) * (red + blue)\n    probability = (numerator / denominator) * (total / (total - 1))\n    return {\n        \"result\": probability,\n        \"steps\": [\"Calculate product of yellow and blue counts\", \"Calculate denominator as (red+yellow)*(red+blue)\", \"Multiply by total/(total-1)\"]\n    }", "required_imports": ["math"]}
{"type": "function", "function": {"name": "SolveLineEllipseIntersections", "description": "Solves for intersection points of a line passing through a given point with an ellipse, returning parametric expressions for coordinates", "parameters": {"type": "object", "properties": {"a": {"type": "float", "description": "Semi-major axis of the ellipse"}, "b": {"type": "float", "description": "Semi-minor axis of the ellipse"}, "x0": {"type": "float", "description": "x-coordinate of the point through which the line passes"}, "y0": {"type": "float", "description": "y-coordinate of the point through which the line passes"}, "m": {"type": "float", "description": "Slope of the line"}}, "required": ["a", "b", "x0", "y0", "m"]}}, "python_implementation": "async def SolveLineEllipseIntersections(a: float, b: float, x0: float, y0: float, m: float) -> Dict:\n    \"\"\"Finds intersection points of line y = m(x - x0) + y0 with ellipse x²/a² + y²/b² = 1\"\"\"\n    import sympy as sp\n    x, y = sp.symbols('x y')\n    line_eq = sp.Eq(y, m*(x - x0) + y0)\n    ellipse_eq = sp.Eq(x**2/a**2 + y**2/b**2, 1)\n    solutions = sp.solve([line_eq, ellipse_eq], (x, y))\n    return {\n        \"intersection_points\": [(float(sol[x]), float(sol[y])) for sol in solutions],\n        \"steps\": [\"Substituted line equation into ellipse\", \"Solved quadratic system\"]\n    }", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "CombinatorialConstraintOptimizer", "description": "Calculates the minimal number of contestants required to achieve a total correct answers under constraints on pairwise problem overlaps and maximum occurrences of problem pairs.", "parameters": {"type": "object", "properties": {"total_correct": {"type": "integer", "description": "Total number of correct answers across all contestants"}, "max_pair_occurrences": {"type": "integer", "description": "Maximum number of times any problem pair can be solved by contestants"}, "n_problems": {"type": "integer", "description": "Total number of problems in the competition"}, "max_per_contestant": {"type": "integer", "description": "Maximum number of problems a single contestant can solve"}}, "required": ["total_correct", "max_pair_occurrences", "n_problems"]}}, "python_implementation": "async def CombinatorialConstraintOptimizer(total_correct: int, max_pair_occurrences: int, n_problems: int, max_per_contestant: int = 6) -> Dict:\n    from math import comb\n    allowed_pairs = max_pair_occurrences * comb(n_problems, 2)\n    n = 1\n    while True:\n        base = total_correct // n\n        remainder = total_correct % n\n        # Check if base and base+1 are within max_per_contestant\n        if base + 1 > max_per_contestant:\n            # Adjust by increasing n until feasible\n            n += 1\n            continue\n        sum_c = remainder * comb(base + 1, 2) + (n - remainder) * comb(base, 2)\n        if sum_c <= allowed_pairs:\n            return {\n                \"result\": n,\n                \"steps\": [f\"Calculated allowed pairs: {allowed_pairs}\", f\"Tested n={n} with sum C(c_i, 2)={sum_c}\"]\n            }\n        n += 1", "required_imports": ["math"]}
{"type": "function", "function": {"name": "stars_and_bars_combinations", "description": "Calculates the number of non-negative integer solutions to x1 + x2 + ... + xk = n using the stars and bars theorem", "parameters": {"type": "object", "properties": {"n": {"type": "integer", "description": "Total number of items to distribute (e.g., voters)"}, "k": {"type": "integer", "description": "Number of distinct categories (e.g., ballot types)"}}, "required": ["n", "k"]}}, "python_implementation": "async def stars_and_bars_combinations(n: int, k: int) -> dict:\n    \"\"\"Computes the number of non-negative integer solutions to x1+...+xk=n\"\"\"\n    import math\n    if n < 0 or k < 1:\n        return {\"error\": \"Invalid input\"}\n    try:\n        result = math.comb(n + k - 1, k - 1)\n        return {\"result\": result, \"steps\": [f\"Apply stars and bars formula: C({n}+{k}-1, {k}-1) = C({n+k-1}, {k-1})\"]}\n    except Exception as e:\n        return {\"error\": str(e)}", "required_imports": ["math"]}
