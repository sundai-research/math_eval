{"type": "function", "function": {"name": "NonIntersectingPathsCount", "description": "Calculates the number of non-intersecting path pairs between two sets of start/end points using the Lindström-Gessel-Viennot lemma (LGV lemma).", "parameters": {"type": "object", "properties": {"start_points": {"type": "array", "description": "List of start coordinates [[x1, y1], [x2, y2]]"}, "end_points": {"type": "array", "description": "List of end coordinates [[x1, y1], [x2, y2]]"}}, "required": ["start_points", "end_points"]}}, "python_implementation": "async def NonIntersectingPathsCount(start_points: list, end_points: list) -> dict:\n    from math import comb\n    \n    # Calculate path counts between each pair\n    M = [[0, 0], [0, 0]]\n    for i in range(2):\n        for j in range(2):\n            dx = end_points[j][0] - start_points[i][0]\n            dy = end_points[j][1] - start_points[i][1]\n            if dx < 0 or dy < 0:\n                M[i][j] = 0\n            else:\n                M[i][j] = comb(dx + dy, dx)\n    \n    # Compute determinant\n    determinant = M[0][0]*M[1][1] - M[0][1]*M[1][0]\n    \n    return {\n        \"result\": determinant,\n        \"steps\": [\n            f\"Matrix M: [[{M[0][0]}, {M[0][1]}], [{M[1][0]}, {M[1][1]}]]\",\n            f\"Determinant calculation: {M[0][0]}*{M[1][1]} - {M[0][1]}*{M[1][0]} = {determinant}\"\n        ]\n    }", "required_imports": ["math.comb"]}
{"type": "function", "function": {"name": "ModularResiduePatternGenerator", "description": "Generates valid residue patterns modulo m that satisfy overlapping sum constraints, and calculates valid number selections from a given set.", "parameters": {"type": "object", "properties": {"modulus": {"type": "integer", "description": "The modulus value (e.g., 3 for this problem)"}, "sequence_length": {"type": "integer", "description": "Length of the sequence to generate patterns for"}, "constraint_relations": {"type": "array", "description": "Array of tuples (i, j) indicating residues at position i must equal residues at position j"}, "sum_constraints": {"type": "array", "description": "Array of tuples (indices, target_sum) where target_sum is modulo value"}}, "required": ["modulus", "sequence_length", "constraint_relations"]}}, "python_implementation": "async def modular_residue_pattern_generator(modulus: int, sequence_length: int, constraint_relations: list, sum_constraints: list = None) -> dict:\n    from itertools import product\n    from collections import defaultdict\n    \n    # Generate all possible residue sequences\n    residues = list(range(modulus))\n    all_patterns = product(residues, repeat=sequence_length)\n    \n    valid_patterns = []\n    for pattern in all_patterns:\n        # Check constraint relations\n        valid = True\n        for i, j in constraint_relations:\n            if pattern[i] != pattern[j]:\n                valid = False\n                break\n        if not valid:\n            continue\n        \n        # Check sum constraints\n        if sum_constraints:\n            for indices, target in sum_constraints:\n                if sum(pattern[i] for i in indices) % modulus != target:\n                    valid = False\n                    break\n            if not valid:\n                continue\n        \n        valid_patterns.append(pattern)\n    \n    # Calculate number of valid number selections\n    num_selections = 0\n    # Precompute counts of numbers in each residue class from 1-10\n    residue_counts = defaultdict(int)\n    for num in range(1, 11):\n        residue_counts[num % modulus] += 1\n    \n    for pattern in valid_patterns:\n        # Check if we can select distinct numbers for this pattern\n        used_residues = set()\n        for r in pattern:\n            if r in used_residues:\n                break\n            used_residues.add(r)\n        else:\n            # Calculate combinations for this pattern\n            product = 1\n            for r in pattern:\n                product *= residue_counts[r]\n            num_selections += product\n    \n    return {\n        'valid_patterns': valid_patterns,\n        'num_valid_sequences': num_selections\n    }", "required_imports": ["itertools.product", "collections.defaultdict"]}
{"type": "function", "function": {"name": "compute_tetrahedron_volume", "description": "Calculates the volume of a tetrahedron given four 3D points using the scalar triple product formula.", "parameters": {"type": "object", "properties": {"points": {"type": "array", "description": "An array of four 3D points, each represented as [x, y, z] coordinates."}}, "required": ["points"]}}, "python_implementation": "async def compute_tetrahedron_volume(points: list) -> dict:\n    from math import sqrt\n    # Extract points\n    p1, p2, p3, p4 = points\n    # Vectors from p1 to p2, p3, p4\n    v1 = [p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2]]\n    v2 = [p3[0]-p1[0], p3[1]-p1[1], p3[2]-p1[2]]\n    v3 = [p4[0]-p1[0], p4[1]-p1[1], p4[2]-p1[2]]\n    # Compute scalar triple product\n    dot_product = v1[0]*(v2[1]*v3[2] - v2[2]*v3[1]) \n               - v1[1]*(v2[0]*v3[2] - v2[2]*v3[0]) \n               + v1[2]*(v2[0]*v3[1] - v2[1]*v3[0])\n    volume = abs(dot_product) / 6\n    return {\n        \"result\": volume,\n        \"steps\": [\n            \"Calculate vectors from p1 to p2, p3, p4\",\n            \"Compute scalar triple product of vectors\",\n            \"Divide absolute value by 6 to get tetrahedron volume\"\n        ]\n    }", "required_imports": ["math"]}
{"type": "function", "function": {"name": "ParametricDistanceMinimizer", "description": "Finds the minimum value of the sum of distances from a parametrically defined point to two fixed points on the complex plane.", "parameters": {"type": "object", "properties": {"x_expr": {"type": "string", "description": "Parametric expression for x-coordinate (e.g., '2 + cos(theta)')"}, "y_expr": {"type": "string", "description": "Parametric expression for y-coordinate (e.g., 'sin(theta)')"}, "z1_real": {"type": "float", "description": "Real part of first fixed point"}, "z1_imag": {"type": "float", "description": "Imaginary part of first fixed point"}, "z2_real": {"type": "float", "description": "Real part of second fixed point"}, "z2_imag": {"type": "float", "description": "Imaginary part of second fixed point"}}, "required": ["x_expr", "y_expr", "z1_real", "z1_imag", "z2_real", "z2_imag"]}}, "python_implementation": "async def ParametricDistanceMinimizer(x_expr: str, y_expr: str, z1_real: float, z1_imag: float, z2_real: float, z2_imag: float) -> dict:\n    import math\n    import numpy as np\n    \n    def distance(theta):\n        x = eval(x_expr.replace('theta', 'theta'))\n        y = eval(y_expr.replace('theta', 'theta'))\n        d1 = math.hypot(x - z1_real, y - z1_imag)\n        d2 = math.hypot(x - z2_real, y - z2_imag)\n        return d1 + d2\n    \n    # Grid search over theta in [0, 2π]\n    theta_values = np.linspace(0, 2*np.pi, 1000)\n    distances = np.array([distance(theta) for theta in theta_values])\n    min_index = np.argmin(distances)\n    \n    return {\n        'minimum_value': distances[min_index],\n        'theta_at_min': theta_values[min_index],\n        'steps': ['Generated parametric equations', 'Computed distances via grid search', 'Found minimum value']\n    }", "required_imports": ["math", "numpy"]}
{"type": "function", "function": {"name": "CubeLineRelationshipAnalyzer", "description": "Analyzes all line pairs in a cube to count those that are both perpendicular and skew. Uses vector math to check geometric relationships.", "parameters": {"type": "object", "properties": {"cube_vertices": {"type": "array", "description": "List of 8 3D coordinates representing the cube's vertices"}}, "required": ["cube_vertices"]}}, "python_implementation": "async def CubeLineRelationshipAnalyzer(cube_vertices: list) -> dict:\n    import numpy as np\n    \n    # Generate all lines from vertices\n    lines = []\n    for i in range(len(cube_vertices)):\n        for j in range(i+1, len(cube_vertices)):\n            lines.append((np.array(cube_vertices[i]), np.array(cube_vertices[j])))\n    \n    count = 0\n    for i in range(len(lines)):\n        for j in range(i+1, len(lines)):\n            line1 = lines[i]\n            line2 = lines[j]\n            \n            # Compute direction vectors\n            dir1 = line1[1] - line1[0]\n            dir2 = line2[1] - line2[0]\n            \n            # Check perpendicularity\n            if np.dot(dir1, dir2) != 0:\n                continue\n            \n            # Check skewness using scalar triple product\n            # Line1: P + t*u, Line2: Q + s*v\n            P, Q = line1[0], line2[0]\n            u, v = dir1, dir2\n            \n            # Check if parallel\n            if np.allclose(np.cross(u, v), 0):\n                continue\n            \n            # Compute scalar triple product (Q-P) ⋅ (u × v)\n            scalar_triple = np.dot(Q - P, np.cross(u, v))\n            if abs(scalar_triple) > 1e-9:  # Not coplanar\n                count += 1\n    \n    return {\n        \"result\": count,\n        \"steps\": [\n            \"Generated all lines from cube vertices\",\n            \"Checked perpendicularity using dot product\",\n            \"Verified skewness via scalar triple product\"\n        ]\n    }", "required_imports": ["numpy"]}
