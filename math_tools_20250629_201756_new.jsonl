{"type": "function", "function": {"name": "LGVNonIntersectingPaths", "description": "Computes the number of non-intersecting path pairs between two pairs of points using the Lindstr\u00f6m-Gessel-Viennot lemma.", "parameters": {"type": "object", "properties": {"start1": {"type": "tuple", "description": "Coordinates (x, y) of the first starting point"}, "end1": {"type": "tuple", "description": "Coordinates (x, y) of the first ending point"}, "start2": {"type": "tuple", "description": "Coordinates (x, y) of the second starting point"}, "end2": {"type": "tuple", "description": "Coordinates (x, y) of the second ending point"}}, "required": ["start1", "end1", "start2", "end2"]}}, "python_implementation": "def LGVNonIntersectingPaths(start1, end1, start2, end2):\n    from math import comb\n    \n    def count_paths(s, e):\n        dx = e[0] - s[0]\n        dy = e[1] - s[1]\n        if dx < 0 or dy < 0:\n            return 0\n        return comb(dx + dy, dx)\n    \n    a = count_paths(start1, end1)\n    b = count_paths(start2, end2)\n    c = count_paths(start1, end2)\n    d = count_paths(start2, end1)\n    \n    result = a * b - c * d\n    return {\n        \"result\": result,\n        \"steps\": [\n            f\"Paths from {start1} to {end1}: {a}\",\n            f\"Paths from {start2} to {end2}: {b}\",\n            f\"Paths from {start1} to {end2}: {c}\",\n            f\"Paths from {start2} to {end1}: {d}\",\n            f\"Non-intersecting paths: {a}*{b} - {c}*{d} = {result}\"\n        ]\n    }", "required_imports": ["math"]}
{"type": "function", "function": {"name": "reflect_point_over_line", "description": "Computes the reflection of a point (x0, y0) over a line defined by Ax + By + C = 0 using the standard reflection formula.", "parameters": {"type": "object", "properties": {"A": {"type": "float", "description": "Coefficient of x in the line equation"}, "B": {"type": "float", "description": "Coefficient of y in the line equation"}, "C": {"type": "float", "description": "Constant term in the line equation"}, "x0": {"type": "float", "description": "x-coordinate of the point to reflect"}, "y0": {"type": "float", "description": "y-coordinate of the point to reflect"}}, "required": ["A", "B", "C", "x0", "y0"]}}, "python_implementation": "def reflect_point_over_line(A: float, B: float, C: float, x0: float, y0: float) -> dict:\n    \"\"\"Reflects (x0, y0) over line Ax + By + C = 0\"\"\"\n    denominator = A**2 + B**2\n    if denominator == 0:\n        return {'error': 'Invalid line equation (A and B cannot both be zero)'}\n    \n    numerator = A*x0 + B*y0 + C\n    x_reflect = x0 - 2*A*numerator / denominator\n    y_reflect = y0 - 2*B*numerator / denominator\n    \n    return {\n        'result': (x_reflect, y_reflect),\n        'steps': [\n            f'Computed numerator: {numerator}',\n            f'Calculated denominator: {denominator}',\n            f'Computed reflected coordinates: ({x_reflect:.4f}, {y_reflect:.4f})'\n        ]\n    }", "required_imports": ["math"]}
{"type": "function", "function": {"name": "acute_triangle_counter", "description": "Counts the number of acute triangles formed by vertices of a regular n-gon. A triangle is acute if all arcs between its vertices are less than 180 degrees.", "parameters": {"type": "object", "properties": {"n": {"type": "integer", "description": "Number of sides in the regular polygon"}}, "required": ["n"]}}, "python_implementation": "def acute_triangle_counter(n: int) -> Dict:\n    \"\"\"Counts acute triangles in regular n-gon\"\"\"\n    from itertools import combinations\n    import math\n    \n    total = 0\n    max_arc_steps = (n - 1) // 2  # Maximum steps for arc < 180 degrees\n    \n    for triplet in combinations(range(n), 3):\n        # Sort triplet to determine consecutive arcs\n        sorted_triplet = sorted(triplet)\n        # Calculate steps between consecutive points\n        steps = [\n            sorted_triplet[1] - sorted_triplet[0],\n            sorted_triplet[2] - sorted_triplet[1],\n            (n - sorted_triplet[2]) + sorted_triplet[0]\n        ]\n        # Check if all arcs are within semicircle\n        if all(step <= max_arc_steps for step in steps):\n            total += 1\n    \n    return {\n        \"total_acute_triangles\": total,\n        \"total_triangles\": math.comb(n, 3),\n        \"probability\": total / math.comb(n, 3)\n    }", "required_imports": ["itertools.combinations", "math"]}
{"type": "function", "function": {"name": "stars_and_bars", "description": "Calculates the number of non-negative integer solutions to x1 + x2 + ... + xk = n using stars and bars theorem", "parameters": {"type": "object", "properties": {"n": {"type": "integer", "description": "Total number of identical items to distribute"}, "k": {"type": "integer", "description": "Number of distinct bins/variables"}}, "required": ["n", "k"]}}, "python_implementation": "def stars_and_bars(n: int, k: int) -> dict:\n    \"\"\"Computes the number of non-negative integer solutions to x1+...+xk=n\"\"\"\n    import math\n    if n < 0 or k < 0:\n        return {\"error\": \"Negative values not allowed\"}\n    try:\n        result = math.comb(n + k - 1, k - 1)\n        return {\"result\": result, \"steps\": [f\"Calculating C({n}+{k}-1, {k}-1) = C({n+k-1}, {k-1})\"]}\n    except ValueError:\n        return {\"error\": \"Invalid input for combination\"}", "required_imports": ["math"]}
{"type": "function", "function": {"name": "QuadraticRootIntervalChecker", "description": "Checks if a quadratic equation has two distinct real roots within a specified interval by verifying discriminant, endpoint function values, and vertex position conditions.", "parameters": {"type": "object", "properties": {"a": {"type": "float", "description": "Coefficient of x\u00b2 in the quadratic equation"}, "b": {"type": "float", "description": "Coefficient of x in the quadratic equation"}, "c": {"type": "float", "description": "Constant term in the quadratic equation"}, "p": {"type": "float", "description": "Left endpoint of the interval"}, "q": {"type": "float", "description": "Right endpoint of the interval"}}, "required": ["a", "b", "c", "p", "q"]}}, "python_implementation": "def QuadraticRootIntervalChecker(a: float, b: float, c: float, p: float, q: float) -> dict:\n    import math\n    # Calculate discriminant\n    discriminant = b**2 - 4*a*c\n    # Check if discriminant is positive\n    has_distinct_roots = discriminant > 0\n    # Calculate function values at endpoints\n    f_p = a*p**2 + b*p + c\n    f_q = a*q**2 + b*q + c\n    # Check if endpoints are positive (for a > 0)\n    endpoint_conditions = (f_p > 0) and (f_q > 0)\n    # Calculate vertex x-coordinate\n    vertex_x = -b/(2*a)\n    # Check if vertex is within the interval\n    vertex_in_interval = (p < vertex_x < q)\n    # Return results\n    return {\n        'has_distinct_roots': has_distinct_roots,\n        'endpoint_conditions': endpoint_conditions,\n        'vertex_in_interval': vertex_in_interval,\n        'discriminant': discriminant,\n        'f_p': f_p,\n        'f_q': f_q,\n        'vertex_x': vertex_x\n    }", "required_imports": ["math"]}
{"type": "function", "function": {"name": "TrigonometricEquationSolver", "description": "Solves symbolic trigonometric equations involving multiple variables and returns solutions in terms of inverse trigonometric functions", "parameters": {"type": "object", "properties": {"equation": {"type": "string", "description": "Symbolic equation to solve (e.g., 'sin(x) + cos(y) = 1')"}, "variables": {"type": "array", "description": "List of variables to solve for (e.g., ['x', 'y'])"}}, "required": ["equation", "variables"]}}, "python_implementation": "def TrigonometricEquationSolver(equation: str, variables: list) -> dict:\n    from sympy import symbols, Eq, solve\n    from sympy.parsing.sympy_parser import parse_expr\n    \n    # Parse equation\n    expr = parse_expr(equation)\n    \n    # Create symbols\n    sym_vars = symbols(' '.join(variables))\n    \n    # Solve equation\n    solution = solve(expr, sym_vars)\n    \n    return {\n        'solution': str(solution),\n        'steps': ['Parsed equation', 'Created symbolic variables', 'Solved equation']\n    }", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "path_count_tool", "description": "Calculates the number of valid paths between two points with step constraints", "parameters": {"type": "object", "properties": {"start": {"type": "int", "description": "Starting position"}, "end": {"type": "int", "description": "Ending position"}, "steps": {"type": "int", "description": "Number of steps allowed"}}, "required": ["start", "end", "steps"]}}, "python_implementation": "def path_count_tool(start: int, end: int, steps: int) -> Dict:\n    \"\"\"Calculate number of paths with step constraints\"\"\"\n    from math import comb\n    \n    # Check if end is reachable in steps\n    delta = end - start\n    if (steps + delta) % 2 != 0 or abs(delta) > steps:\n        return {\"result\": 0, \"steps\": [f\"Delta {delta} not reachable in {steps} steps\"]}\n    \n    # Calculate number of up steps needed\n    up_steps = (steps + delta) // 2\n    if up_steps < 0 or up_steps > steps:\n        return {\"result\": 0, \"steps\": [f\"Invalid up steps {up_steps}\"]}\n    \n    # Calculate combinations\n    result = comb(steps, up_steps)\n    return {\"result\": result, \"steps\": [f\"Calculated C({steps}, {up_steps}) = {result}\"]}", "required_imports": ["math.comb"]}
{"type": "function", "function": {"name": "SymbolicGeometricEquationSolver", "description": "Solves systems of symbolic equations derived from geometric constraints (angles, distances, sphere tangency) using symbolic computation.", "parameters": {"type": "object", "properties": {"equations": {"type": "array", "description": "List of symbolic equations (as strings) representing geometric constraints"}, "variables": {"type": "array", "description": "List of symbolic variables to solve for"}}, "required": ["equations", "variables"]}}, "python_implementation": "def SymbolicGeometricEquationSolver(equations: list, variables: list) -> dict:\n    from sympy import symbols, Eq, solve\n    \n    # Parse variables\n    sym_vars = symbols(variables)\n    \n    # Parse equations\n    parsed_eqs = []\n    for eq in equations:\n        parsed_eqs.append(Eq(eval(eq, {var: sym_vars[i] for i, var in enumerate(variables)})))\n    \n    # Solve system\n    solution = solve(parsed_eqs, sym_vars)\n    \n    return {\n        \"solution\": str(solution),\n        \"steps\": [\"Parsed equations:\", \", \".join(equations), \"Solved for variables:\", \", \".join(variables)]\n    }", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "SymbolicEquationSolver", "description": "Solves systems of equations symbolically using SymPy, useful for geometric constraints and algebraic manipulations", "parameters": {"type": "object", "properties": {"equations": {"type": "list", "description": "List of symbolic equations to solve"}, "variables": {"type": "list", "description": "List of variables to solve for"}}, "required": ["equations", "variables"]}}, "python_implementation": "def SymbolicEquationSolver(equations: list, variables: list) -> dict:\n    \"\"\"Solves a system of symbolic equations using SymPy\"\"\"\n    from sympy import symbols, Eq, solve, sympify\n\n    # Convert to SymPy symbols\n    sym_vars = symbols(variables)\n\n    # Process equations based on format\n    sym_eqs = []\n    for eq in equations:\n        if isinstance(eq, str):\n            if '=' in eq:\n                # Handle equations with equals sign: \"2*k**3 - 16*k**2 + 37*k - 11 = 0\"\n                left, right = eq.split('=', 1)\n                left_expr = sympify(left.strip())\n                right_expr = sympify(right.strip())\n                sym_eqs.append(Eq(left_expr, right_expr))\n            else:\n                # Handle string expressions - assume they equal zero\n                expr = sympify(eq)\n                sym_eqs.append(Eq(expr, 0))\n        else:\n            # Handle original tuple format: (left_side, right_side)\n            sym_eqs.append(Eq(eq[0], eq[1]))\n\n    # Solve the system\n    solution = solve(sym_eqs, sym_vars)\n\n    return {\n        \"solution\": str(solution),\n        \"steps\": [\"Converted to SymPy symbols\", \"Processed string equations\", \"Solved system using solve()\"]\n    }", "required_imports": ["sympy"]}
{"type": "function", "function": {"name": "plane_cube_intersection_tool", "description": "Calculates intersection points between a plane and a unit cube's edges, enabling cross-sectional analysis for volume calculations.", "parameters": {"type": "object", "properties": {"a": {"type": "float", "description": "Coefficient of x in plane equation ax + by + cz + d = 0"}, "b": {"type": "float", "description": "Coefficient of y in plane equation"}, "c": {"type": "float", "description": "Coefficient of z in plane equation"}, "d": {"type": "float", "description": "Constant term in plane equation"}}, "required": ["a", "b", "c", "d"]}}, "python_implementation": "def plane_cube_intersection_tool(a: float, b: float, c: float, d: float) -> Dict:\n    import math\n    # Define unit cube edges (12 edges)\n    edges = [\n        [(0,0,0), (1,0,0)], [(1,0,0), (1,1,0)], [(1,1,0), (0,1,0)], [(0,1,0), (0,0,0)],\n        [(0,0,0), (0,0,1)], [(1,0,0), (1,0,1)], [(1,1,0), (1,1,1)], [(0,1,0), (0,1,1)],\n        [(0,0,1), (1,0,1)], [(1,0,1), (1,1,1)], [(1,1,1), (0,1,1)], [(0,1,1), (0,0,1)]\n    ]\n    intersections = []\n    for p1, p2 in edges:\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        # Parametric line equations\n        dx = x2 - x1\n        dy = y2 - y1\n        dz = z2 - z1\n        # Plane equation: a*x + b*y + c*z + d = 0\n        # Solve for t: a(x1 + t*dx) + b(y1 + t*dy) + c(z1 + t*dz) + d = 0\n        A = a*dx + b*dy + c*dz\n        B = a*x1 + b*y1 + c*z1 + d\n        if A != 0:\n            t = -B / A\n            if 0 <= t <= 1:\n                x = x1 + t*dx\n                y = y1 + t*dy\n                z = z1 + t*dz\n                intersections.append((x, y, z))\n    return {\n        \"intersections\": intersections,\n        \"steps\": [\"Calculated intersections for all cube edges\", \"Filtered valid t values\"]\n    }", "required_imports": ["math"]}
